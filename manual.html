<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Font Chef: Manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Font Chef
   &#160;<span id="projectnumber">1.0.1</span>
   </div>
   <div id="projectbrief">A font cooking library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This manual presents how can you use Font Chef to load, cook fonts and render text. In the end you will have an example that would need just few adjustments to compile and run.</p>
<h1><a class="anchor" id="loading-and-cooking"></a>
Loading and cooking</h1>
<p>The <a class="el" href="structfc__font.html" title="A fc_font struct represents all data and metadata about a font.">fc_font</a> structure and it's C++ counterpart, class <a class="el" href="classfc_1_1font.html" title="A wrapper class for fc_font.">fc::font</a>, holds both font information (e.g, advance width, line height, etc) and it's pixel data after cooking. Fonts need a height, that can be either defined in pixels or in points and a color before being cooked.</p>
<p>Cooking then is the process of producing a bitmap with all the rendered glyphs that you are interested in and also having their positioning, kerning, and other information stored for later use.</p>
<h2><a class="anchor" id="constructing"></a>
Constructing</h2>
<p>To construct a <code><a class="el" href="structfc__font.html" title="A fc_font struct represents all data and metadata about a font.">fc_font</a></code>/<code><a class="el" href="classfc_1_1font.html" title="A wrapper class for fc_font.">fc::font</a></code>, you will first need to have the truetype font loaded in memory. To load a TTF file you can use any method available (e.g, <code>fopen()/fread()</code>). You then call <code>fc_construct</code> passing the font buffer, the font height and the font color or if using C+ you can use either <a class="el" href="classfc_1_1font.html" title="A wrapper class for fc_font.">fc::font</a> constructor directy or use <code>fc::from</code> (which is useful when chaining methods).</p>
<p>Before going forward, let's assume a function that fully reads a file and returns a pointer to it:</p>
<p><b>File reading function</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> * read_file(<span class="keywordtype">char</span> <span class="keyword">const</span> * path);</div>
</div><!-- fragment --><p>Then it is time to use this font data to construct a <code><a class="el" href="structfc__font.html" title="A fc_font struct represents all data and metadata about a font.">fc_font</a></code>/<code><a class="el" href="classfc_1_1font.html" title="A wrapper class for fc_font.">fc::font</a></code> instance:</p>
<p><b>In C99</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__font.html">fc_font</a> * font = <a class="code" href="group__font.html#ga6eaabbfdad1d4f2c2e04407c1d0f97ec">fc_construct</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>);</div>
</div><!-- fragment --><p><b>In C++</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><a class="code" href="classfc_1_1font.html">fc::font</a> font_x(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>); <span class="comment">// or</span></div>
<div class="line"><a class="code" href="classfc_1_1font.html">fc::font</a> font = <a class="code" href="group__cpp.html#ga786f7bc26dcbc437400bb3483fee009f">fc::from</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>); <span class="comment">// which is the method we&#39;ll use forward</span></div>
</div><!-- fragment --><p>Checkout the <a class="el" href="group__color.html">Color</a> reference to see more options for defining a color in Font Chef.</p>
<h2><a class="anchor" id="unicode-blocks"></a>
Adding unicode blocks</h2>
<p>A unicode block (or range) is defined by it's first codepoint and it's last, inclusive. For instance, the <em>Basic Latin</em> unicode block has the first codepoint being <code>0x20</code> which is the space character and it's last codepoint is <code>0x7f</code>, which is the DEL character (which might not have a corresponding glyph).</p>
<p>Before cooking, you need to add unicode blocks to a <code><a class="el" href="structfc__font.html" title="A fc_font struct represents all data and metadata about a font.">fc_font</a></code>/<code><a class="el" href="classfc_1_1font.html" title="A wrapper class for fc_font.">fc::font</a></code>. These are the characters that you intend to use after cooking.</p>
<p>Font Chef has bundled almost all unicode blocks defined by unicode.org. You can use them by adding <code>#include "font-chef/unicode-block.h"</code> in your code. Let's update our code:</p>
<p><b>In C99</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__font.html">fc_font</a> * font = <a class="code" href="group__font.html#ga6eaabbfdad1d4f2c2e04407c1d0f97ec">fc_construct</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>);</div>
<div class="line"><a class="code" href="group__font.html#ga218cfb52a088baad0605d79d4719b82b">fc_add</a>(font, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#afecaa34ede18b0c1b0b26e9056698434">first</a>, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#a7a125d294a467b71c98202468395d04a">last</a>);</div>
</div><!-- fragment --><p><b>In C++</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><a class="code" href="classfc_1_1font.html">fc::font</a> font = <a class="code" href="group__cpp.html#ga786f7bc26dcbc437400bb3483fee009f">fc::from</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>)</div>
<div class="line">                   .<a class="code" href="classfc_1_1font.html#a630da851bf99ba7ce84061fd66358dcc">add</a>(fc_basic_latin);</div>
</div><!-- fragment --><h2><a class="anchor" id="cooking"></a>
Cooking</h2>
<p>As mentioned earlier, cooking is the process of rasterizing the glyphs at the specified font-height and creating an atlas with it. The end result is a bitmap with all the added codepoints rendered and information tables with enough data to produce a sequence of clipping and target rectangles when asked to.</p>
<p><b>In C99</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font and cooks it</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__font.html">fc_font</a> * font = <a class="code" href="group__font.html#ga6eaabbfdad1d4f2c2e04407c1d0f97ec">fc_construct</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>);</div>
<div class="line"><a class="code" href="group__font.html#ga218cfb52a088baad0605d79d4719b82b">fc_add</a>(font, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#afecaa34ede18b0c1b0b26e9056698434">first</a>, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#a7a125d294a467b71c98202468395d04a">last</a>);</div>
<div class="line"><a class="code" href="group__font.html#ga2b49aee4f4cb9bc01171cdd24d6b4e6e">fc_cook</a>(font);</div>
</div><!-- fragment --><p><b>In C++</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font and cooks it</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><a class="code" href="classfc_1_1font.html">fc::font</a> font = <a class="code" href="group__cpp.html#ga786f7bc26dcbc437400bb3483fee009f">fc::from</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>)</div>
<div class="line">                   .<a class="code" href="classfc_1_1font.html#a630da851bf99ba7ce84061fd66358dcc">add</a>(fc_basic_latin);</div>
<div class="line">                   .<a class="code" href="classfc_1_1font.html#ac5440c3d90388f9967c9dd4a09dbc486">cook</a>();</div>
</div><!-- fragment --><p>It is important to have in mind that after cooking, you can't just simply add more blocks and expect them to be rasterized. You will have to cook the font again, so it is advisable to add all the unicode blocks you need and cook the font just once.</p>
<h2><a class="anchor" id="texture"></a>
Creating a texture</h2>
<p>After cooking you'll have at your disposal a bitmap to create a texture to use as a clipping source. This part is really up to whatever rendering engine you're using, for this manual we will assume the following structure and function exists:</p>
<p><b>Texture creation function:</b> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>texture; <span class="comment">// forward declaration</span></div>
<div class="line"><span class="keyword">struct </span>texture * texture_from_pixels(<span class="keywordtype">void</span> * pixels, uint32_t width, uint32_t height);</div>
</div><!-- fragment --><p>Font Chef produces a 4 bytes-per-pixel in RGBA format that can be used to create hardware-accelerated textures to render on screen or to any other purpose you can think of. To extract the pixel data from a <code><a class="el" href="structfc__font.html" title="A fc_font struct represents all data and metadata about a font.">fc_font</a></code>/<code><a class="el" href="classfc_1_1font.html" title="A wrapper class for fc_font.">fc::font</a></code> structure:</p>
<p><b>In C</b></p>
<div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font and cooks it</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__font.html">fc_font</a> * font = <a class="code" href="group__font.html#ga6eaabbfdad1d4f2c2e04407c1d0f97ec">fc_construct</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>);</div>
<div class="line"><a class="code" href="group__font.html#ga218cfb52a088baad0605d79d4719b82b">fc_add</a>(font, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#afecaa34ede18b0c1b0b26e9056698434">first</a>, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#a7a125d294a467b71c98202468395d04a">last</a>);</div>
<div class="line"><a class="code" href="group__font.html#ga2b49aee4f4cb9bc01171cdd24d6b4e6e">fc_cook</a>(font);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__pixels.html">fc_pixels</a> const * pixels = <a class="code" href="group__font.html#ga706c0d6b01757e90c20161f9363943ae">fc_get_pixels</a>(font);</div>
<div class="line"><span class="keyword">struct </span>texture * t = texture_from_pixels(pixels-&gt;<a class="code" href="structfc__pixels.html#ac3229f317aacb50aeccc52ac6e8bbaa4">data</a>, pixels-&gt;<a class="code" href="structfc__pixels.html#aa456d8cbc8e2cfffeafc624f777f1d6e">dimensions</a>.<a class="code" href="structfc__size.html#af60bb2e9db20e669b8077100e455e235">width</a>, pixel-&gt;dimensions.height);</div>
</div><!-- fragment --><p><b>In C++</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font and cooks it</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><a class="code" href="classfc_1_1font.html">fc::font</a> font = <a class="code" href="group__cpp.html#ga786f7bc26dcbc437400bb3483fee009f">fc::from</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>)</div>
<div class="line">                   .<a class="code" href="classfc_1_1font.html#a630da851bf99ba7ce84061fd66358dcc">add</a>(fc_basic_latin);</div>
<div class="line">                   .<a class="code" href="classfc_1_1font.html#ac5440c3d90388f9967c9dd4a09dbc486">cook</a>();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structfc__pixels.html">fc_pixels</a> pixels = font.<a class="code" href="classfc_1_1font.html#a41e859a6052dba1f55fc1a9b6618a169">pixels</a>();</div>
<div class="line">texture * t = texture_from_pixels(pixels.<a class="code" href="structfc__pixels.html#ac3229f317aacb50aeccc52ac6e8bbaa4">data</a>, pixels.<a class="code" href="structfc__pixels.html#aa456d8cbc8e2cfffeafc624f777f1d6e">dimensions</a>.<a class="code" href="structfc__size.html#af60bb2e9db20e669b8077100e455e235">width</a>, pixel.dimensions.height);</div>
</div><!-- fragment --><h1><a class="anchor" id="rendering-text"></a>
Rendering text</h1>
<p>After cooking and texture creation, everything is in place to render some text. Rather than directly displaying text Font Chef returns an array of source (or clip) and destination rectangles that you should use to instruct your rendering engine to render the part of the texture corresponding to the characters/glyphs in your text to the correct position in your render target (be it the video framebuffer or another image).</p>
<p>All code in the following sections are built upon the previous examples but for brevity they are not repeated here so you should assume the <code>font</code> has already been cooked and a <code>texture</code> is already created.</p>
<h2><a class="anchor" id="character-mapping"></a>
Producing a character map</h2>
<p>In C there is the type <code><a class="el" href="structfc__character__mapping.html" title="Specifies source and target rectangles to render the specified codepoint.">fc_character_mapping</a></code>. It represents a single character source and target rectangles so you will need an array of them. In C++ there is a wrapper class, <code><a class="el" href="structfc_1_1render__result.html" title="Wraps a std::vector&lt;fc_character_mapping&gt;.">fc::render_result</a></code>, that adds some syntatic sugar and supports iterators and ranged-based loops.</p>
<p>Examples on how to produce character mappings:</p>
<p><b>In C</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span> text[] = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__character__mapping.html">fc_character_mapping</a> mapping[256]; <span class="comment">// needs to be at least strlen(text) in size</span></div>
<div class="line"><span class="keywordtype">int</span> glyph_count = <a class="code" href="group__font.html#gadbb524812ee58bddb80e7b3098c5e4eb">fc_render</a>(font, text, strlen(text), mapping);</div>
</div><!-- fragment --><p><b>In C++</b></p>
<div class="fragment"><div class="line"><a class="code" href="structfc_1_1render__result.html">fc::render_result</a> result = font.<a class="code" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">render</a>(<span class="stringliteral">&quot;Hello, world!&quot;</span>);</div>
</div><!-- fragment --><p><code><a class="el" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0" title="Produces clipping and target rectangles to render specified text.">fc::font::render</a></code> accepts all types that the <code>std::string</code> constructor accepts.</p>
<p>If you need to render again you can reuse the same <code><a class="el" href="structfc_1_1render__result.html" title="Wraps a std::vector&lt;fc_character_mapping&gt;.">fc::render_result</a></code> object:</p>
<div class="fragment"><div class="line"><a class="code" href="structfc_1_1render__result.html">fc::render_result</a> result = font.<a class="code" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">render</a>(<span class="stringliteral">&quot;Hello, world!&quot;</span>);</div>
<div class="line">result = font.<a class="code" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">render</a>(<span class="stringliteral">&quot;Hello, moon!&quot;</span>, result);</div>
</div><!-- fragment --><h2><a class="anchor" id="wrapalign"></a>
Wrapping and aligning text</h2>
<p>A common need when rendering text is the ability to wrap and align it in the available width. Font Chef has for this purpose <code><a class="el" href="group__font.html#ga34bb83df7a83a4a4163d25f4af8221b9" title="A shortcut for rendering and then wrapping the result.">fc_render_wrapped</a></code> and <code><a class="el" href="group__character-mapping.html#gaad940e9fcd70cedb8f7c5d44acb2e587" title="Word-wraps characters in an array of fc_character_mapping.">fc_wrap</a></code> for programs written in C and <code><a class="el" href="structfc_1_1render__result.html#a539ba8258ed2d611e142c8f6b7ff8159" title="Calls fc_wrap on the vector of character mappings.">fc::render_result::wrap</a></code> for programs written in C++. Before wrapping, you will need to know the line width, the line height and the space width. You don't need to figure out all this information yourself, Font Chef has <code><a class="el" href="group__font.html#gacc3a7d7870d7a3deeff86b1a3cdbbeb0" title="Returns the space glyph width and height for this font at its specified size.">fc_get_space_metrics</a></code> to help.</p>
<p><b>In C</b></p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span> text[] = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__character__mapping.html">fc_character_mapping</a> mapping[256]; <span class="comment">// needs to be at least strlen(text) in size</span></div>
<div class="line"><span class="keywordtype">int</span> glyph_count = <a class="code" href="group__font.html#gadbb524812ee58bddb80e7b3098c5e4eb">fc_render</a>(font, text, strlen(text), mapping);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// wraps the produced rendering at 80px using the space character&#39;s</span></div>
<div class="line"><span class="comment">// height as line height and it&#39;s width as the space width.</span></div>
<div class="line"><span class="comment">// Also right-aligns your text</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__size.html">fc_size</a> space_metrics = <a class="code" href="group__font.html#gacc3a7d7870d7a3deeff86b1a3cdbbeb0">fc_get_space_metrics</a>(font);</div>
<div class="line"><a class="code" href="group__character-mapping.html#gaad940e9fcd70cedb8f7c5d44acb2e587">fc_wrap</a>(mapping, glyph_count, 80, space_metrics.<a class="code" href="structfc__size.html#a49f78ba8f4123c3e245b1f54a4c9030c">height</a>, space_metrics.<a class="code" href="structfc__size.html#af60bb2e9db20e669b8077100e455e235">width</a>, fc_align_right);</div>
</div><!-- fragment --><p><code><a class="el" href="group__font.html#ga34bb83df7a83a4a4163d25f4af8221b9" title="A shortcut for rendering and then wrapping the result.">fc_render_wrapped</a></code> is a function you can call to perform the above in a single step with the difference that instead if receiving the line height, it receives a line height multiplier.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span> text[] = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__character__mapping.html">fc_character_mapping</a> mapping[256]; <span class="comment">// needs to be at least strlen(text) in size</span></div>
<div class="line"><span class="keywordtype">int</span> glyph_count = <a class="code" href="group__font.html#ga34bb83df7a83a4a4163d25f4af8221b9">fc_render_wrapped</a>(font, text, strlen(text), 80, 1.0f, fc_align_left, mapping);</div>
</div><!-- fragment --><p><b>In C++</b></p>
<div class="fragment"><div class="line"><a class="code" href="structfc_1_1render__result.html">fc::render_result</a> result = font.<a class="code" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">render</a>(<span class="stringliteral">&quot;Hello, world!&quot;</span>).<a class="code" href="structfc_1_1render__result.html#a539ba8258ed2d611e142c8f6b7ff8159">wrap</a>(80);</div>
</div><!-- fragment --><p><code><a class="el" href="structfc_1_1render__result.html" title="Wraps a std::vector&lt;fc_character_mapping&gt;.">fc::render_result</a></code> holds a pointer to the original font so it is used internally to calculate sensible defaults. It also aligns-left by default. Although <code><a class="el" href="structfc_1_1render__result.html#a539ba8258ed2d611e142c8f6b7ff8159" title="Calls fc_wrap on the vector of character mappings.">fc::render_result::wrap</a></code> does not need to receive a line height, you can pass a multiplier to it to increase spacing between lines. It also accepts the alignment requirement:</p>
<div class="fragment"><div class="line"><a class="code" href="structfc_1_1render__result.html">fc::render_result</a> result = font.<a class="code" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">render</a>(<span class="stringliteral">&quot;Hello, world!&quot;</span>).<a class="code" href="structfc_1_1render__result.html#a539ba8258ed2d611e142c8f6b7ff8159">wrap</a>(80, 1.5f, fc_align_right);</div>
</div><!-- fragment --><p>Checkout <a class="el" href="group__character-mapping.html#ga21083b23aeda48e899c06a2c45703fd1" title="Specifies an aligment to be used when rendering wrapped text.">fc_alignment</a> <code>enum</code> for more alignment options (<em>spoiler: they're <code>fc_align_left</code>, <code>fc_align_center</code> and <code>fc_align_right</code></em>).</p>
<dl class="section warning"><dt>Warning</dt><dd>Re-wrapping produces weird results. If you need to re-wrap your text constantly it is advisable to use <code><a class="el" href="group__font.html#ga34bb83df7a83a4a4163d25f4af8221b9" title="A shortcut for rendering and then wrapping the result.">fc_render_wrapped</a></code> rather than <code><a class="el" href="group__font.html#gadbb524812ee58bddb80e7b3098c5e4eb" title="Produces a list of source and target rectangles that can be used as clipping rects (or UV maps) for t...">fc_render</a></code> and <code><a class="el" href="group__character-mapping.html#gaad940e9fcd70cedb8f7c5d44acb2e587" title="Word-wraps characters in an array of fc_character_mapping.">fc_wrap</a></code>.</dd></dl>
<h3><a class="anchor" id="moving-your-text"></a>
Moving your text</h3>
<p>The above code would render your text assuming a baseline at <code>y = 0</code>, so you might not be able to see the result later. To fix that all target rectangles should be adjusted in regards to where you want your baseline to be. To help with that Font Chef provides the <code><a class="el" href="group__character-mapping.html#gaa068b4d63f94670a3bb3eab961791c6f" title="Moves all the target rectangles by left pixels horizontally and baseline pixels vertically.">fc_move</a></code> function in C and <code><a class="el" href="structfc_1_1render__result.html#a696030017b3bb14fefd9c67a4fd9eba9" title="This is a wrapper to fc_move. Consult its documentation for more information.">fc::render_result::move</a></code> in C++. Use them when you want to move your text horizontally or vertically in regards to the render target.</p>
<p><b>In C</b> </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span> text[] = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__character__mapping.html">fc_character_mapping</a> mapping[256]; <span class="comment">// needs to be at least strlen(text) in size</span></div>
<div class="line"><span class="keywordtype">int</span> glyph_count = <a class="code" href="group__font.html#ga34bb83df7a83a4a4163d25f4af8221b9">fc_render_wrapped</a>(font, text, strlen(text), 80, 1.0f, fc_align_left, mapping);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Move the text vertically adding 128 pixels to the baseline</span></div>
<div class="line"><a class="code" href="group__character-mapping.html#gaa068b4d63f94670a3bb3eab961791c6f">fc_move</a>(mapping, glyph_count, 0.0f, 128);</div>
</div><!-- fragment --><p><b>In C++</b> </p><div class="fragment"><div class="line"><span class="comment">// Move the text vertically adding 128 pixels to the baseline</span></div>
<div class="line"><a class="code" href="structfc_1_1render__result.html">fc::render_result</a> result = font.<a class="code" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">render</a>(<span class="stringliteral">&quot;Hello, world!&quot;</span>).<a class="code" href="structfc_1_1render__result.html#a539ba8258ed2d611e142c8f6b7ff8159">wrap</a>(80).<a class="code" href="structfc_1_1render__result.html#a696030017b3bb14fefd9c67a4fd9eba9">move</a>(0.0f, 128.0f);</div>
</div><!-- fragment --><h2><a class="anchor" id="rendering"></a>
Rendering text</h2>
<p>After all above, we are ready to render some text on screen (or any other render target). To that end, let's assume such a function exists:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>texture;</div>
<div class="line"><span class="keywordtype">void</span> render(<span class="keyword">struct</span> texture * texture, <a class="code" href="structfc__rect.html">fc_rect</a> src, <a class="code" href="structfc__rect.html">fc_rect</a> target);</div>
</div><!-- fragment --><p>What it would do is to render a part of the texture (specified by the <code>src</code> rect) to a specific position at the rendering target (specified by the <code>target</code> rect).</p>
<p>Our code so far is this:</p>
<p><b>In C</b></p>
<div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font and cooks it</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__font.html">fc_font</a> * font = <a class="code" href="group__font.html#ga6eaabbfdad1d4f2c2e04407c1d0f97ec">fc_construct</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>);</div>
<div class="line"><a class="code" href="group__font.html#ga218cfb52a088baad0605d79d4719b82b">fc_add</a>(font, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#afecaa34ede18b0c1b0b26e9056698434">first</a>, fc_basic_latin.<a class="code" href="structfc__unicode__block.html#a7a125d294a467b71c98202468395d04a">last</a>);</div>
<div class="line"><a class="code" href="group__font.html#ga2b49aee4f4cb9bc01171cdd24d6b4e6e">fc_cook</a>(font);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__pixels.html">fc_pixels</a> const * pixels = <a class="code" href="group__font.html#ga706c0d6b01757e90c20161f9363943ae">fc_get_pixels</a>(font);</div>
<div class="line"><span class="keyword">struct </span>texture * t = texture_from_pixels(pixels-&gt;<a class="code" href="structfc__pixels.html#ac3229f317aacb50aeccc52ac6e8bbaa4">data</a>, pixels-&gt;<a class="code" href="structfc__pixels.html#aa456d8cbc8e2cfffeafc624f777f1d6e">dimensions</a>.<a class="code" href="structfc__size.html#af60bb2e9db20e669b8077100e455e235">width</a>, pixel-&gt;dimensions.height);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span> text[] = <span class="stringliteral">&quot;Hello world!&quot;</span>;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structfc__character__mapping.html">fc_character_mapping</a> mapping[256]; <span class="comment">// needs to be at least strlen(text) in size</span></div>
<div class="line"><span class="keywordtype">int</span> glyph_count = <a class="code" href="group__font.html#ga34bb83df7a83a4a4163d25f4af8221b9">fc_render_wrapped</a>(font, text, strlen(text), 80, 1.0f, fc_align_left, mapping);</div>
</div><!-- fragment --><p><b>In C++</b> </p><div class="fragment"><div class="line"><span class="comment">// construct a 30px, red-colored font and cooks it</span></div>
<div class="line"><span class="keywordtype">void</span> * font_data = read_file(<span class="stringliteral">&quot;Nunito-Regular.ttf&quot;</span>);</div>
<div class="line"><a class="code" href="classfc_1_1font.html">fc::font</a> font = <a class="code" href="group__cpp.html#ga786f7bc26dcbc437400bb3483fee009f">fc::from</a>(font_data, <a class="code" href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a>(30), <a class="code" href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a>)</div>
<div class="line">                   .<a class="code" href="classfc_1_1font.html#a630da851bf99ba7ce84061fd66358dcc">add</a>(fc_basic_latin);</div>
<div class="line">                   .<a class="code" href="classfc_1_1font.html#ac5440c3d90388f9967c9dd4a09dbc486">cook</a>();</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structfc__pixels.html">fc_pixels</a> pixels = font.<a class="code" href="classfc_1_1font.html#a41e859a6052dba1f55fc1a9b6618a169">pixels</a>();</div>
<div class="line">texture * t = texture_from_pixels(pixels.<a class="code" href="structfc__pixels.html#ac3229f317aacb50aeccc52ac6e8bbaa4">data</a>, pixels.<a class="code" href="structfc__pixels.html#aa456d8cbc8e2cfffeafc624f777f1d6e">dimensions</a>.<a class="code" href="structfc__size.html#af60bb2e9db20e669b8077100e455e235">width</a>, pixel.dimensions.height);</div>
<div class="line"><a class="code" href="structfc_1_1render__result.html">fc::render_result</a> result = font.<a class="code" href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">render</a>(<span class="stringliteral">&quot;Hello, world!&quot;</span>).<a class="code" href="structfc_1_1render__result.html#a539ba8258ed2d611e142c8f6b7ff8159">wrap</a>(80);</div>
</div><!-- fragment --><p>So what is left is to call the texture render function defined earlier:</p>
<p><b>In C</b> </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; txt_glyph_count; i++) {</div>
<div class="line">  render(font_texture, mapping[i].<a class="code" href="structfc__character__mapping.html#a14b7ade1433e20a6b4ad002e1b67942c">source</a>, mapping[i].<a class="code" href="structfc__character__mapping.html#ab8baede6c424e32626e76777e8feb9a9">target</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>In C++</b> </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; map : result) {</div>
<div class="line">  render(font_texture, map.source, map.target);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="done"></a>
Done!</h1>
<p>By now you have all the tools needed to use Font Chef in your code to render some text. Don't forget to free all the memory you are no longer using. In C, you will have to call <code><a class="el" href="group__font.html#gacdac1246f9601a6b643f6344b00883b6" title="Destroys and frees all memory allocated by this library.">fc_destruct</a></code> on the <code><a class="el" href="structfc__font.html" title="A fc_font struct represents all data and metadata about a font.">fc_font</a></code> instance you created. For C++ this is not necessary as <code><a class="el" href="classfc_1_1font.html" title="A wrapper class for fc_font.">fc::font</a></code> does this in it's destructor.</p>
<p>You don't need to manually free values returned by any of Font Chef functions (not even the pixels array). But depending on your rendering and file reading functions you might have to release the texture pointer and the buffer used to read the TTF file.</p>
<p>For a more complete example using SDL2 as it's rendering backend, checkout the <a href="examples.html">examples</a> page. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="astructfc_1_1render__result_html"><div class="ttname"><a href="structfc_1_1render__result.html">fc::render_result</a></div><div class="ttdoc">Wraps a std::vector&lt;fc_character_mapping&gt;.</div><div class="ttdef"><b>Definition:</b> render-result.hpp:30</div></div>
<div class="ttc" id="agroup__character-mapping_html_gaad940e9fcd70cedb8f7c5d44acb2e587"><div class="ttname"><a href="group__character-mapping.html#gaad940e9fcd70cedb8f7c5d44acb2e587">fc_wrap</a></div><div class="ttdeci">void fc_wrap(struct fc_character_mapping mapping[], size_t count, float line_width, float line_height, float space_width, enum fc_alignment alignment)</div><div class="ttdoc">Word-wraps characters in an array of fc_character_mapping.</div></div>
<div class="ttc" id="astructfc__pixels_html_aa456d8cbc8e2cfffeafc624f777f1d6e"><div class="ttname"><a href="structfc__pixels.html#aa456d8cbc8e2cfffeafc624f777f1d6e">fc_pixels::dimensions</a></div><div class="ttdeci">struct fc_size dimensions</div><div class="ttdoc">Width and height of this pixel data. Buffer size would be dimensions.width * dimensions....</div><div class="ttdef"><b>Definition:</b> font.h:43</div></div>
<div class="ttc" id="astructfc_1_1render__result_html_a539ba8258ed2d611e142c8f6b7ff8159"><div class="ttname"><a href="structfc_1_1render__result.html#a539ba8258ed2d611e142c8f6b7ff8159">fc::render_result::wrap</a></div><div class="ttdeci">render_result &amp; wrap(float line_width, float line_height_multiplier=1.0f, fc_alignment alignment=fc_align_left) &amp;</div><div class="ttdoc">Calls fc_wrap on the vector of character mappings.</div><div class="ttdef"><b>Definition:</b> render-result.hpp:110</div></div>
<div class="ttc" id="astructfc__size_html_a49f78ba8f4123c3e245b1f54a4c9030c"><div class="ttname"><a href="structfc__size.html#a49f78ba8f4123c3e245b1f54a4c9030c">fc_size::height</a></div><div class="ttdeci">float height</div><div class="ttdoc">The height value.</div><div class="ttdef"><b>Definition:</b> size.h:29</div></div>
<div class="ttc" id="agroup__font_html_ga2b49aee4f4cb9bc01171cdd24d6b4e6e"><div class="ttname"><a href="group__font.html#ga2b49aee4f4cb9bc01171cdd24d6b4e6e">fc_cook</a></div><div class="ttdeci">void fc_cook(struct fc_font *font)</div><div class="ttdoc">Generates a bitmap and corresponding character information for a font.</div></div>
<div class="ttc" id="agroup__color_html_gaf91ac7954ab73a8bf8bdec08f53d8000"><div class="ttname"><a href="group__color.html#gaf91ac7954ab73a8bf8bdec08f53d8000">fc_color_red</a></div><div class="ttdeci">struct fc_color const fc_color_red</div><div class="ttdoc">RGBA: #FF0000FF</div></div>
<div class="ttc" id="astructfc__size_html"><div class="ttname"><a href="structfc__size.html">fc_size</a></div><div class="ttdoc">Contains width and height as floats.</div><div class="ttdef"><b>Definition:</b> size.h:24</div></div>
<div class="ttc" id="agroup__font_html_ga6eaabbfdad1d4f2c2e04407c1d0f97ec"><div class="ttname"><a href="group__font.html#ga6eaabbfdad1d4f2c2e04407c1d0f97ec">fc_construct</a></div><div class="ttdeci">struct fc_font * fc_construct(uint8_t const *font_data, struct fc_font_size font_size, struct fc_color font_color)</div><div class="ttdoc">Constructs a fc_font structure with the provided font, a size (either in pixels or points) and a font...</div></div>
<div class="ttc" id="astructfc_1_1render__result_html_a696030017b3bb14fefd9c67a4fd9eba9"><div class="ttname"><a href="structfc_1_1render__result.html#a696030017b3bb14fefd9c67a4fd9eba9">fc::render_result::move</a></div><div class="ttdeci">render_result &amp; move(float left=0.0f, float baseline=0.0f) &amp;</div><div class="ttdoc">This is a wrapper to fc_move. Consult its documentation for more information.</div><div class="ttdef"><b>Definition:</b> render-result.hpp:164</div></div>
<div class="ttc" id="aclassfc_1_1font_html"><div class="ttname"><a href="classfc_1_1font.html">fc::font</a></div><div class="ttdoc">A wrapper class for fc_font.</div><div class="ttdef"><b>Definition:</b> font.hpp:29</div></div>
<div class="ttc" id="agroup__font_html_ga34bb83df7a83a4a4163d25f4af8221b9"><div class="ttname"><a href="group__font.html#ga34bb83df7a83a4a4163d25f4af8221b9">fc_render_wrapped</a></div><div class="ttdeci">int fc_render_wrapped(struct fc_font const *font, unsigned char const *text, size_t byte_count, size_t line_width, float line_height_multiplier, enum fc_alignment alignment, struct fc_character_mapping *mapping)</div><div class="ttdoc">A shortcut for rendering and then wrapping the result.</div></div>
<div class="ttc" id="astructfc__font_html"><div class="ttname"><a href="structfc__font.html">fc_font</a></div><div class="ttdoc">A fc_font struct represents all data and metadata about a font.</div></div>
<div class="ttc" id="agroup__font_html_ga218cfb52a088baad0605d79d4719b82b"><div class="ttname"><a href="group__font.html#ga218cfb52a088baad0605d79d4719b82b">fc_add</a></div><div class="ttdeci">void fc_add(struct fc_font *font, uint32_t first, uint32_t last)</div><div class="ttdoc">Adds the given unicode range to the list of blocks to be cooked. You must add blocks before calling f...</div></div>
<div class="ttc" id="aclassfc_1_1font_html_a41e859a6052dba1f55fc1a9b6618a169"><div class="ttname"><a href="classfc_1_1font.html#a41e859a6052dba1f55fc1a9b6618a169">fc::font::pixels</a></div><div class="ttdeci">fc_pixels pixels() const</div><div class="ttdoc">Obtains a structure containing a pointer to the pixel data and it's dimensions.</div><div class="ttdef"><b>Definition:</b> font.hpp:169</div></div>
<div class="ttc" id="agroup__font_html_gadbb524812ee58bddb80e7b3098c5e4eb"><div class="ttname"><a href="group__font.html#gadbb524812ee58bddb80e7b3098c5e4eb">fc_render</a></div><div class="ttdeci">int fc_render(struct fc_font const *font, unsigned char const *text, size_t byte_count, struct fc_character_mapping *mapping)</div><div class="ttdoc">Produces a list of source and target rectangles that can be used as clipping rects (or UV maps) for t...</div></div>
<div class="ttc" id="aclassfc_1_1font_html_ac5440c3d90388f9967c9dd4a09dbc486"><div class="ttname"><a href="classfc_1_1font.html#ac5440c3d90388f9967c9dd4a09dbc486">fc::font::cook</a></div><div class="ttdeci">font &amp; cook() &amp;</div><div class="ttdoc">Cooks all the added unicode ranges into a pixmap and clipping information.</div><div class="ttdef"><b>Definition:</b> font.hpp:142</div></div>
<div class="ttc" id="astructfc__character__mapping_html_a14b7ade1433e20a6b4ad002e1b67942c"><div class="ttname"><a href="structfc__character__mapping.html#a14b7ade1433e20a6b4ad002e1b67942c">fc_character_mapping::source</a></div><div class="ttdeci">struct fc_rect source</div><div class="ttdoc">The source rectangle that should be used to clip the texture/surface.</div><div class="ttdef"><b>Definition:</b> character-mapping.h:38</div></div>
<div class="ttc" id="astructfc__unicode__block_html_a7a125d294a467b71c98202468395d04a"><div class="ttname"><a href="structfc__unicode__block.html#a7a125d294a467b71c98202468395d04a">fc_unicode_block::last</a></div><div class="ttdeci">uint32_t last</div><div class="ttdoc">The last unicode point in this range (inclusive)</div><div class="ttdef"><b>Definition:</b> unicode-block.h:26</div></div>
<div class="ttc" id="astructfc__size_html_af60bb2e9db20e669b8077100e455e235"><div class="ttname"><a href="structfc__size.html#af60bb2e9db20e669b8077100e455e235">fc_size::width</a></div><div class="ttdeci">float width</div><div class="ttdoc">The width value.</div><div class="ttdef"><b>Definition:</b> size.h:26</div></div>
<div class="ttc" id="astructfc__character__mapping_html_ab8baede6c424e32626e76777e8feb9a9"><div class="ttname"><a href="structfc__character__mapping.html#ab8baede6c424e32626e76777e8feb9a9">fc_character_mapping::target</a></div><div class="ttdeci">struct fc_rect target</div><div class="ttdoc">The target rectangle, or where in the target coordinates you should render the clipped texture.</div><div class="ttdef"><b>Definition:</b> character-mapping.h:42</div></div>
<div class="ttc" id="agroup__cpp_html_ga786f7bc26dcbc437400bb3483fee009f"><div class="ttname"><a href="group__cpp.html#ga786f7bc26dcbc437400bb3483fee009f">fc::from</a></div><div class="ttdeci">font from(uint8_t const *font_data, fc::font_size const &amp;font_size, fc::color const &amp;font_color)</div><div class="ttdoc">A helper method to ease font cooking via method chaining.</div><div class="ttdef"><b>Definition:</b> font.hpp:237</div></div>
<div class="ttc" id="aclassfc_1_1font_html_a90e36efac0ee0e2d7e26262e606de5f0"><div class="ttname"><a href="classfc_1_1font.html#a90e36efac0ee0e2d7e26262e606de5f0">fc::font::render</a></div><div class="ttdeci">fc::render_result render(std::string const &amp;text) const</div><div class="ttdoc">Produces clipping and target rectangles to render specified text.</div><div class="ttdef"><b>Definition:</b> font.hpp:190</div></div>
<div class="ttc" id="agroup__font_html_gacc3a7d7870d7a3deeff86b1a3cdbbeb0"><div class="ttname"><a href="group__font.html#gacc3a7d7870d7a3deeff86b1a3cdbbeb0">fc_get_space_metrics</a></div><div class="ttdeci">struct fc_size fc_get_space_metrics(struct fc_font const *font)</div><div class="ttdoc">Returns the space glyph width and height for this font at its specified size.</div></div>
<div class="ttc" id="astructfc__unicode__block_html_afecaa34ede18b0c1b0b26e9056698434"><div class="ttname"><a href="structfc__unicode__block.html#afecaa34ede18b0c1b0b26e9056698434">fc_unicode_block::first</a></div><div class="ttdeci">uint32_t first</div><div class="ttdoc">The first unicode point in this range.</div><div class="ttdef"><b>Definition:</b> unicode-block.h:23</div></div>
<div class="ttc" id="agroup__font_html_ga706c0d6b01757e90c20161f9363943ae"><div class="ttname"><a href="group__font.html#ga706c0d6b01757e90c20161f9363943ae">fc_get_pixels</a></div><div class="ttdeci">struct fc_pixels const  * fc_get_pixels(struct fc_font const *font)</div><div class="ttdoc">Returns the pixel data after for a font generated after a fc_cook was called.</div></div>
<div class="ttc" id="astructfc__rect_html"><div class="ttname"><a href="structfc__rect.html">fc_rect</a></div><div class="ttdoc">Represents a rectangle with left, top, right and bottom float values.</div><div class="ttdef"><b>Definition:</b> rect.h:33</div></div>
<div class="ttc" id="astructfc__character__mapping_html"><div class="ttname"><a href="structfc__character__mapping.html">fc_character_mapping</a></div><div class="ttdoc">Specifies source and target rectangles to render the specified codepoint.</div><div class="ttdef"><b>Definition:</b> character-mapping.h:34</div></div>
<div class="ttc" id="agroup__font-size_html_ga6e72ad699f2e88321d1d6cf91abaee86"><div class="ttname"><a href="group__font-size.html#ga6e72ad699f2e88321d1d6cf91abaee86">fc_px</a></div><div class="ttdeci">struct fc_font_size fc_px(float value)</div><div class="ttdoc">Constructs and returns a fc_size value specified as pixels.</div></div>
<div class="ttc" id="agroup__character-mapping_html_gaa068b4d63f94670a3bb3eab961791c6f"><div class="ttname"><a href="group__character-mapping.html#gaa068b4d63f94670a3bb3eab961791c6f">fc_move</a></div><div class="ttdeci">void fc_move(struct fc_character_mapping *mapping, size_t count, float left, float baseline)</div><div class="ttdoc">Moves all the target rectangles by left pixels horizontally and baseline pixels vertically.</div></div>
<div class="ttc" id="aclassfc_1_1font_html_a630da851bf99ba7ce84061fd66358dcc"><div class="ttname"><a href="classfc_1_1font.html#a630da851bf99ba7ce84061fd66358dcc">fc::font::add</a></div><div class="ttdeci">font &amp; add(fc_unicode_block const &amp;block) &amp;</div><div class="ttdoc">Adds a new unicode block to be cooked.</div><div class="ttdef"><b>Definition:</b> font.hpp:85</div></div>
<div class="ttc" id="astructfc__pixels_html"><div class="ttname"><a href="structfc__pixels.html">fc_pixels</a></div><div class="ttdoc">A structure holding pixel data and its dimensions.</div><div class="ttdef"><b>Definition:</b> font.h:34</div></div>
<div class="ttc" id="astructfc__pixels_html_ac3229f317aacb50aeccc52ac6e8bbaa4"><div class="ttname"><a href="structfc__pixels.html#ac3229f317aacb50aeccc52ac6e8bbaa4">fc_pixels::data</a></div><div class="ttdeci">unsigned char * data</div><div class="ttdoc">The pixel data produced after fc_cook, a 4-byte-per-pixel RGBA bitmap.</div><div class="ttdef"><b>Definition:</b> font.h:38</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
